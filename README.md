# Welcome to Project python-visitors codefly examples!

## Setup

### Install the codefly CLI

```shell
brew tap codefly-dev/cli 
brew install codefly
```

### Requirement

- Docker


## What are we building

### 3.5 Tier App

A "3 Tier App" to show the statistics of the visitors to a website. The app will have a web front end, a backend API, a cache (the 0.5 part) and a database.


### Getting it running locally

If you want to run the full stack, go inside the website service folder and run:

```shell
cd applications/web/services/frontend
codefly run service
```

will run everything. Public endpoints should receive a URL that you can see in the logs.

You can also run with the `--server` flag that will also run `codefly` frontend component.

```shell
codefly run service --server
```

This is convenient to see your project, the dependencies, look at the logs, query your endpoints, etc...

If you only want to run the backend

```shell
cd applications/backend/services/server
codefly run service
```

If you want to check out the frontend companion to the CLI, add the `--server` flag:

```shell
codefly run service --server
```

### Deploying to local Kubernetes

Go to the frontend server folder and run:

#### Build the Docker images

```shell
codefly build service
```

#### Create the k8s manifests and applying them

```shell
codefly deploy service --apply
```

#### Validate

```shell
codefly expose
```

It should give you local URL to browse to your website and API.

Only **public** endpoints are exposed like this.

### Structure of the project

Even if overkill here, we will create two applications

- `web`: The web front end
- `backend`: The backend API


## Getting started

### Creating the project

Where you want your projects to be located

```shell
codefly create project python-visitors
```

### Creating the applications

Inside the project folder:

```shell
codefly add application web
codefly add application backend
```

## Backend

We will run these inside the `backend` application folder.

### Creating the API server

We will use the `python-fastapi` agent to create the API server. The creation should check that the poetry "runtime" dependency is satisfied.

https://python-poetry.org/docs/


```shell
codefly add service server --agent=python-fastapi
```

### What do we have?

Let's run our. In the `server` service folder.

```shell
codefly run service
```

Codefly will log where the service is running. It will be something like:

```shell
backend/server >> will run on: http://localhost:42042
```

Note: the port is automatically generated by codefly, this is the default strategy:

TODO: Finish

```
// APP-SVC-API
// Between 1100(0) and 4999(9)
// First 11 -> 49: hash app
// Next 0 -> 9: hash app+svc
// Next 0 - 9: hash name
// Last Digit: API
// 0: TCP
// 1: HTTP/ REST
// 2: gRPC
```

Port are deterministic, so you can share tooling that depend on them. A good example is Kreya or other tool for REST or HTTP testing.

Servers should always include a REST endpoint for their version. You can test it out:

```shell
curl http://localhost:42042/version
```

But we can get a lot more information about this server.

Let's re-run with the additional `--server` flag. This will start `codefly` frontend component.

```shell
codefly run service --server
```

You should see a line like
    
```shell
Serving codefly webserver at http://localhost:10001
```

TODO: Take screenshots

REST Testing is broken. We need to fix it.

### Hot-reload

While you are still running the server, try to change the `main.py` file. You should see the server restart automatically.

## Database


### Creating the store service

We will use a Cloud version of Postgres for the database, in that case RDS.

We use the `external-postgres` agent: it will use a Docker version of postgres.

```shell
codefly add service store --agent=external-postgres
```

Pick the database name corresponding to your external database. It will matter for migrations.


### What do we have?

Let's run our. In the `store` service folder.

```shell
codefly run service
```

It will print a bunch of logs from the postgres container.

To ignore them, let's go into the `service.codefly.yaml` configuration file and we will do two things:

- `silent: true`

This will hide the logs.

- `persist: true`

This will keep the container running when you stop codefly. So you can persist data between runs.

Note that the container name will be something like:

`codefly-python-visitors-backend-store`

This way, you can work with multiple projects, applications, services and not have conflicts.

### Access the Database

As before, the address of the database is found most easily in logs or in the frontend.

```shell
backend/store >> will run on address: localhost:42350

Credentials can be found in the `configurations` folder of the service.

In our case, the configutation input is the credentials for the database but the configuration out is the connection string. We will see how it is used later.


Open `DBeaver` and create a connection to test it out.

TODO: Screenshot.


### Migrations

The agent created a default migration with the `store` table, the name of the service. We will keep this name but change the schema:

```shell
CREATE TABLE IF NOT EXISTS "store" (
   "date" DATE NOT NULL,
   "visits" INT NOT NULL,
   PRIMARY KEY ("date")
);
```

Re-start codefly or if you selected the `hot-reload` option, the migration should be applied automatically.

TODO: Screenshot maybe?

```shell
backend/store >> will run on address: localhost:42350
backend/store || (INFO) connection connection=postgresql://user:password@localhost:42350/visitors?sslmode=disable
backend/store >> silent mode
backend/store || (INFO) applying migration: 1_create_table.up.sql
```

## Making it work

### Linking the two services

This is where codefly will start to show its power. We will link the `server` and `store` services.

In the `server` service folder, run:

```shell
codefly add dependency
```

And select the `store` service.

Now try running again the `server`. You should see a line like:

```shell
Running <server> with these dependent services: backend/store
```


### Adding the database logic in the `server` service

We have added some data to get a better API definition in `visit.py` and we have implemented the database logic in `store.py`.

The important part is how we get the connection string for the database.

codefly has SDK for python that accesses the configuration for a given service. 

In that case, since `store` is a dependency for the `server` and it exposes the `postgres/connection` configuration, we can directly get it:

```python
connection = codefly.secret(service="store", name="postgres", key="connection")
```

The setup for the database client is done in `setup.py`.

This code will work locally and for your deployment in Kubernetes or elsewhere!

No more having to deal with environment variable jujitsu. This is codefly's job.

You focus on building your app, we take care of the annoying stuff.

This area is too manual for now. Part of the "Update" API for codefly that I haven't had the time to touch.

In `src`, run `poetry add psycopg2` to get that dependency working, there will be an additional setup for the "Build" phase but this will get cleaned up.

### Testing the API

Now run again the `server`:
```shell
codefly run service
```

and test the API:

```shell
❯ curl -X POST http://localhost:42042/visit
{"visit_number":4}%                                                                                                                                                                                                  
❯ curl http://localhost:42042/visit/statistics
{"total_visits":4,"visits":[{"date":"2024-03-19T00:00:00","visits":4}]}%
```

## Adding caching with redis

### Adding a cache service with the `redis agent`

We will use the `redis` agent to create the cache. It exposes two endpoints: one for `write` and one for `read`.

Note: These two endpoints will work whether you use read replicas or not. Read and write are functionalities that don't depend  on the actual infrastructure.


```shell
codefly add service cache --agent=redis
```

The agent installation should ask you whether you actually want to run read replicas. It should depend on your use case.

### Linking the `server` and `cache` services

In the `server` service folder, run:

```shell
codefly add dependency
```

### Adding the business logic

We implemented the cache logic in `cache.py` and added it to the REST endpoint.

The important part is as with the database, how do we get the redis connection strings.

Remember, we have two endpoints *write* and *read* provided by this `redis` agent so we expect two connection strings as well!

As for the database, we rely on the SDK to get our configuration:

```python
connection_write_redis = codefly.secret(service="cache", name="redis", key="write")
connection_read_redis = codefly.secret(service="cache", name="redis", key="read")
```

Note: How we know what provider info are exposed by a given service? This is actually part of the service API and we display it for example in the CLI frontend companion.

TODO: Do we want the SDK to list the configuration available?

## Frontend

### Creating the frontend service

In the `web` application folder, run:

```
codefly add service frontend --agent=nextjs
```

And create dependency to the `backend`:

```shell
codefly add dependency
```
in the `frontend` service folder, and select the `backend` service in "another application".


## Local Kubernetes

### Build the Docker images

We will build the Docker image for the `server`.

Inside the `server` service folder, first add the `postgres` dependency in the `service.codefly.yaml` file:

```yaml
spec:
  # ...
  runtime-packages: [libpq5]
```

```shell
codefly build service
```

Something interesting happened, you should see that codefly also built an image for the `store`. First, since we add a dependency on the store, codefly ran automatically the build for the dependency.

But we are using an agent for an external Postgres DB, so what's in this Docker image?

__Migrations__!

The Docker image for the `store` service contains the migrations. This is a good way to keep the migrations in a safe place and to be able to run them in a CI/CD pipeline.

It will be ran automatically as a Job, but more on that later.

Now, locally, you should get new Docker images.

### Deployment to local Kubernetes

codefly provides the `heroku` type of experience where you can just develop locally and push. Codefly platform is using Kubernetes with all the best practices, security and scalability with your public endpoints behind a Load Balancer. More on that later.

But for now, we are in demo mode, so we will use a local cluster, Docker Desktop Kubernetes for example.

First we need something to play the role of the external database. And we will use our own `store` service, therefore we copy the `configurations/local` to `configurations/localkube`

If you used the `persist` option, your local Postgres should still be running. Otherwise, run it from inside the `store` service.

We need to give the information about where the external Postgres is running by creating a dns entry in the service `dns/localkube` folder:
```yaml
- endpoint: tcp
  host: host.docker.internal
  port: 42330
```

You will recognize the port of the store from before.

The host is `host.docker.internal` because we are running the Kubernetes cluster on the host machine. Obviously, with RDS or another cloud provider, you would use the regular endpoint.


Now let's deploy our stack!

```shell
codefly deploy service --env=localkube --apply
```

To access the endpoints, you can just run:
```shell
codefly expose
```

And you will get the URL to access your website and API.
