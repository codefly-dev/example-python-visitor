# Welcome to Project python-visitors codefly examples!

## What are we building

### 3 Tier App

A "3 Tier App" to show the statistics of the visitors to a website. The app will have a web front end, a backend API, a cache and a database.


### Structure of the project

Even if overkill here, we will create two applications

- `web`: The web front end
- `backend`: The backend API


## Getting started

### Creating the project

Where you want your projects to be located

```shell
codefly create project python-visitors
```

### Creating the applications

Inside the project folder:

```shell
codefly add application web
codefly add application backend
```

## Backend

We will run these inside the `backend` application folder.

### Creating the API server

We will use the `python-fastapi` agent to create the API server. The creation should check that the poetry "runtime" dependency is satisfied.

https://python-poetry.org/docs/


```shell
codefly add service server --agent=python-fastapi
```

### What do we have?

Let's run our. In the `server` service folder.

```shell
codefly run service
```

Codefly will log where the service is running. It will be something like:

```shell
backend/server >> will run on: http://localhost:42042
```

Note: the port is automatically generated by codefly, this is the default strategy:

TODO: Finish

```
// APP-SVC-API
// Between 1100(0) and 4999(9)
// First 11 -> 49: hash app
// Next 0 -> 9: hash app+svc
// Next 0 - 9: hash name
// Last Digit: API
// 0: TCP
// 1: HTTP/ REST
// 2: gRPC
```

Port are deterministic, so you can share tooling that depend on them. A good example is Kreya or other tool for REST or HTTP testing.

Servers should always include a REST endpoint for their version. You can test it out:

```shell
curl http://localhost:42042/version
```

But we can get a lot more information about this server.

Let's re-run with the additional `--server` flag. This will start `codefly` frontend component.

```shell
codefly run service --server
```

You should see a line like
    
```shell
Serving codefly webserver at http://localhost:10001
```

TODO: Take screenshots

REST Testing is broken. We need to fix it.

### Hot-reload

While you are still running the server, try to change the `main.py` file. You should see the server restart automatically.

## Database


### Creating the store service

We will use a Cloud version of Postgres for the database, in that case RDS.

We use the `external-postgres` agent: it will use a Docker version of postgres.

```shell
codefly add service store --agent=external-postgres
```

Pick the database name corresponding to your external database. It will matter for migrations.


### What do we have?

Let's run our. In the `store` service folder.

```shell
codefly run service
```

It will print a bunch of logs from the postgres container.

To ignore them, let's go into the `service.codefly.yaml` configuration file and we will do two things:

- `silent: true`

This will hide the logs.

- `persist: true`

This will keep the container running when you stop codefly. So you can persist data between runs.

Note that the container name will be something like:

`codefly-python-visitors-backend-store`

This way, you can work with multiple projects, applications, services and not have conflicts.

### Access the Database

As before, the address of the database is found most easily in logs or in the frontend.

```shell
backend/store >> will run on address: localhost:42350

Credentials can be found in the `providers` folder of the service.

Note on provider: a service has provider information IN and has provider info out.

In our case, the provider information is the credentials for the database but the information out is the connection string. We will see how it is used later.


Open `DBeaver` and create a connection to test it out.

TODO: Screenshot.


### Migrations

The agent created a default migration with the `store` table, the name of the service. We will keep this name but change the schema:

```shell
CREATE TABLE IF NOT EXISTS "store" (
   "date" DATE NOT NULL,
   "visits" INT NOT NULL,
   PRIMARY KEY ("date")
);
```

Re-start codefly or if you selected the `hot-reload` option, the migration should be applied automatically.

TODO: Screenshot maybe?

```shell
backend/store >> will run on address: localhost:42350
backend/store || (INFO) connection connection=postgresql://user:password@localhost:42350/visitors?sslmode=disable
backend/store >> silent mode
backend/store || (INFO) applying migration: 1_create_table.up.sql
```

## Making it work

### Linking the two services

This is where codefly will start to show its power. We will link the `server` and `store` services.

In the `server` service folder, run:

```shell
codefly add dependency
```

And select the `store` service.

Now try running again the `server`. You should see a line like:

```shell
Running <server> with these dependent services: backend/store
```


### Adding the database logic in the `server` service

We have added some data to get a better API definition in `visit.py` and we have implemented the database logic in `store.py`.

The important part is how we get the connection string for the database.

codefly has SDK for python that accesses the provider information for a given service. 

In that case, since `store` is a dependency for the `server` and it exposes the `postgres/connection` provider info, we can directly get it:

```python
connection = codefly.get_service_provider_info(application="backend", service="store", name="postgres", key="connection")
```

This code will work locally and for your deployment in Kubernetes or elsewhere!

No more having to deal with environment variable jujitsu. This is codefly's job.

You focus on building your app, we take care of the annoying stuff.

This area is too manual for now. Part of the "Update" API for codefly that I haven't had the time to touch.

In `src`, run `poetry add psycopg2` to get that dependency working, there will be an additional setup for the "Build" phase but this will get cleaned up.

### Testing the API

Now run again the `server`:
```shell
codefly run service
```

and test the API:

```shell
❯ curl -X POST http://localhost:42042/visit
{"visit_number":4}%                                                                                                                                                                                                  
❯ curl http://localhost:42042/visit/statistics
{"total_visits":4,"visits":[{"date":"2024-03-19T00:00:00","visits":4}]}%
```

## Local Kubernetes

### Build the Docker images

We will build the Docker image for the `server`.

Inside the `server` service folder, first add the `postgres` dependency in the `service.codefly.yaml` file:

```yaml
spec:
  # ...
  runtime-packages: [libpq5]
```

```shell
codefly build service
```

Something interesting happened, you should see that codefly also built an image for the `store`. First, since we add a dependency on the store, codefly ran automatically the build for the dependency.

But we are using an agent for an external Postgres DB, so what's in this Docker image?

__Migrations__!

The Docker image for the `store` service contains the migrations. This is a good way to keep the migrations in a safe place and to be able to run them in a CI/CD pipeline.

It will be ran automatically as a Job, but more on that later.

Now, locally, you should get new Docker images.

### Deployment to local Kubernetes

codefly provides the `heroku` type of experience where you can just develop locally and push. Codefly platform is using Kubernetes with all the best practices, security and scalability with your public endpoints behind a Load Balancer. More on that later.

But for now, we are in demo mode, so we will use a local cluster, Docker Desktop Kubernetes for example.

First we need something to play the role of the external database. And we will use our own `store` service.

If you used the `persist` option, your local Postgres should still be running. Otherwise, run it from inside the `store` service.

We need to give the information about where the external Postgres is running.

We will a special file in the project level `providers`: the `dns.env`.

```
backend/store=host.docker.internal:42350
```

You will recognize the port of the store from before.

The host is `host.docker.internal` because we are running the Kubernetes cluster on the host machine. Obviously, with RDS or another cloud provider, you would use the regular endpoint.


Now let's deploy our stack!

```shell
codefly deploy service --apply
```
